---
title: 【直观算法】Egg Puzzle 鸡蛋难题
date: 2018-10-11 22:39:43
tags: 
- DP
- Optimization
categories:
- Algorithm
---

【阅读时间】9500+字 | 15 - 20 min
【阅读内容】Google面试题：100层楼，两个鸡蛋**最少用多少次**能测出鸡蛋的**会在哪一层碎**

<!-- more -->

分享者是最大的受益者，感谢您的阅读！[知乎文章链接，走过路过求个赞](https://zhuanlan.zhihu.com/p/47184570)，[相关问题答案]()

# 题目描述

有一栋楼共`100层`，一个鸡蛋从`第x层`及以上的楼层落下来会摔破， 在`第x层`以下的楼层落下不会摔破。给你2个鸡蛋，设计方案找出`x`，并且保证在最坏情况下， **最小化鸡蛋下落的次数**

有些时候仍的东西可能会变化，比如变成**瓶子**

这道题目的整个解答过程设计到了几乎所有的逻辑思维，工程思维，当真是一道海纳百川的面试题

## 求什么？

利用`抽象思维`，**符号化**题目描述

⭐️〔题目要求〕找到 $x$ 层落下不会碎，$x+1$ 层落下会碎的**临界层**所需要的最少尝试次数 $M$ (for minimum)

# 解题思路

使用`等价思维`，如何计算出最小的尝试次数？换言之，就是**如何计算出这个结果**，找出公式 $r = f()$

## 一个鸡蛋

假设最后结果设为 $r$ 次（r for result）。使用`归纳思维`，先看只拥有`1`个鸡蛋的情况，思考什么是`最坏情况`。你可能说可以直接使用二分法，但请注意，你只有`1`个鸡蛋，又必须能找到**临界层**。所以，`1`个鸡蛋的情况下，**最坏情况**为 $r = 100$ 

> 大多数情况下，我们都低估了**理解题意**的重要性

但这么思考**还不够究竟**，缺乏`抽象思维`。通过逻辑思考，可以得出 $r =100$ 的答案，但没有一个抽象的公式化结论？或者说，如何使用一个公式算出 $r$ ？接下来就来解决这个问题

假设**临界层**分别为 $x = 1,2,3 \dots 100$ ，因为你只有`1`个鸡蛋，所以唯一**可选策略**就是从`1`层开始**一层一层**尝试，对应的每个策略选择最坏情况的**尝试步数**（比如 $x = 95$ ，从`1`层开始尝试为`95`次）那么可以得到对应的 $r = 1,2,3 \dots 99,100$

所以可抽象化得到我们**待求的符号表达式** 
$$
r = \max_{1 \leqslant x \leqslant N}(\forall S_i(x)) \tag{1}
$$
公式的语言型描述是：对于每一个可能的**临界层** $x$，可以得到使用可选择策略 $S_i()$ 需要的**尝试步数**。在每一个可能，选出其中的最大值（即最坏情况），为最终答。无论**临界层** $x$ 在哪一层，**只有一个鸡蛋的情况下**，总是需要考虑**最坏情况**

> 这道题目，对`1`个鸡蛋问题的深刻理解异常重要。只有深刻理解基石逻辑才能更好的解决问题

## 两个鸡蛋

### 粗调和细调

依据`粗条细调思维`，我们有一次试错的机会。那么可以思考，假设第一个鸡蛋在 $k$ 层`碎了`，意味着什么？意味着，待求的**临界层** $x$ 一定满足 $1 \leqslant x \lt k$ ，或者记为 $[1,k)$ ，就把待求量限制到了一个更小的范围内，可以提高找到目标值的效率

我们已经知道要用第一个鸡蛋做**粗调**，`碎了`之后，使用第二个鸡蛋，参照`1`个鸡蛋的原则进行**细调**。下一步，问题就变成了一个策略问题，即**❓第一个鸡蛋应该在哪些层数仍**的问题

在一层楼，丢了一个鸡蛋，除了`碎了`这个结果，还有另一种可能性，即`没碎`。这句话是一个**极为关键的信号**，背后在告诉我们这是一个**树形结构**问题，下面就把这条树形结构链分析出来

> **将数据结构与问题描述的勾连能力**是衡量算法能力的重要指标

- 没有分叉，一路推理，为**〔线性结构〕**
- 看到决策结果**有分叉**，用**〔树形结构〕**
- 若在推理过程中，产生了**交汇**，则用**〔图结构〕**

### 树形结构

假设第一个鸡蛋的楼层策略是 $k_1, k_2,\cdots,k_p$ ，其中 $p$ 是`仍的总次数`，楼高记为 $N$ 。比如如果你选择在 $20,40,60,80$ 层仍，那么 $p=4$ ，根据题意，有 $1 \lt k_1 \lt k_2 \lt \cdots \lt k_{p-1} \lt k_p \lt 100$ 。画出树形示意图，如下图所示

<div align="center"><img src="【直观算法】Egg Puzzle 鸡蛋难题/Tree.png" alt="" width="700"></div>

图最上方的数轴就是一个**横放的楼**，$k_0 = 1$ 是第一层

解释一下这棵树。在每一层扔下一个鸡蛋时，都有两种可能，`碎了`和`没碎`，分别对应了两个分支。一旦`碎了`，那么就使用`1`个鸡蛋的问题思路来解题，直到找到**临界层**。在 $k\_1$层没碎，那么需要在 $k\_2$ 层继续尝试，直到最高层 $N$ 找到**临界层**

观察这个树状图，怎样从树中获得我们希望得到的答案呢？〔输入自变量〕 $k_1, k_2,\cdots,k_p$ 〔待求〕最小的尝试次数（即所有策略中**最大值的最小值**）➜ 等价于，求一个策略组合 $k_1, k_2,\cdots,k_p$，使得**树的高度最小**

如果还是有些无法理解，此时，最好的方法就是**看特例（举例子）**

比如 $k_1 = 50$，意思是在`50层`扔下第一个鸡蛋

- 如果`碎了`，那么接下来的尝试方法就是从第`1`层开始一个一个往上尝试，直到`49`层，所以我们的答案 $r = 50$ （不记得如何计算这个值可以参考[一个鸡蛋](#一个鸡蛋)） 
- 如果`没碎`，那么第一个鸡蛋继续在 $k_2 = 75$ 层的地方扔下，假设还是`没碎`，继续从 $k_3 = 90$ 层的地方扔下，此时碎了，那么第二课鸡蛋就需要从`76`层开始，一层一层往上尝试直到`89`层，需要 $89-76+1=24$ 次，第一个鸡蛋已经扔了`3`次，最后得到`没碎`情况下的例子的答案 $r=27$ 次

> 在上面的例子中，需要体会**最坏情况下的最小值**的意义，或者说，尝试的**最大步数的最小值**。如何判断对一道题目有没有完全吃透，看能否清晰的走完每一个例子，就能一窥一二

### 最优解的情况证明

⭐️ 接下里就是确定树形状了，从**直觉**来看，这棵树，如果树的形状倾向于类似**满二叉树**，那么树的**高度最小**。❓ 但如何证明**这个直觉**的正确性呢？既然要计算树高，那么就把每一个**叶子节点的树高**一个一个**列出来**
{% raw %} 
$$
\left.
\begin{array}{l}
k_1 \\
k_2 -k_1 +1 \\
k_3-k_2 +2 \\
\cdots \\
k_p - k_{p-1} +{p-1} \\
N- k_p + p \\
\end{array}
\right\} \sum = N + \frac{(1+p)p}{2} \tag{2}
$$
{% endraw %}

经过计算发现，他们的和是个**定值**。那么使用**反证法**，假设这棵树不是满树，因为高度和为定值，那么必定有一个**高于平均值得树**存在，记为 $T$ ，根据最高树的最小值的要求 $H_a ＜ H_T$ （$H_a$为满树的高度），答案是$H_a$ 。所以，必定是满树的高满足最大值的最小值的题目条件。证毕

<div align="center"><img src="【直观算法】Egg Puzzle 鸡蛋难题/Tree.png" alt="" width="400"></div>

再参考树的示意图，所谓类似满二叉树是指**每一棵子树的树高相等**，比如列出下面等式（每一行都是左右两颗子树相等）
{% raw %}
$$
\begin{array} \\
k_1 = k_2 - k_1 + 1 &\implies &k_2 = 2k_1 + 1 = k_1 + (k_1 - 1) \\
k_2 -k_1 +1 = k_3-k_2 +2 &\implies &k_3 = 3k_1 -3 = k_1 + (k_1 -1) + (k_1 -2) \\
\cdots \\
\end{array} \\
k_p = N = 100 = k_1 + (k_1-1) + (k_1-2) + \cdots + 1 = \frac{k_1(k_1 + 1)}{2} \tag{3}
$$
{% endraw %}

解得 $k_1 \approx 13.65$ ，考虑到，所有**尝试楼层都是整数**，第一颗鸡蛋最后一次的**尝试区间**需要超过 $N$ 层，所以 $k_1 = \lceil k_1\rceil = 14$ 。如果不明白为什么取上整数不取下整数，试试 $k_1 = 13$ 或 $k_1 = 14$ 对比一下答案，看看谁的尝试次数少即可

有了 $k_1$ ，带回去（2）式，可以知道第一个鸡蛋的扔下楼层策略为 $14,27,39,50,60,69,77,84, 90,95,99$ 。使用这个策略，带回（1）式，假设**临界层**从`1`到`N`层，**分别计算**所需要的**最多尝试次数**，可以得到 $r = 14$  

到此为止，我们已经解决了`2`个鸡蛋的问题，找到了一个很明确的函数，利用`抽象思维`，可以写出它的表达式 $r = f(2, N)$，而这个 $f()$ 即求 $\frac{x(x+1)}{2} = N$ 解 $x$ 的 q$\lceil x \rceil$

# 问题拓展

`2`个鸡蛋`100`层楼已经解决，深究下去，`N`层楼`M`个鸡蛋的问题呢？Leetcode有这道题：[887. Super Egg Drop](https://leetcode.com/problems/super-egg-drop/description/)

> 算法题如果刷题多的读者会**快速反应出**，这个问题可能可以用**动态规划**来解，但是在这里我还是想用一种**推理的思维**来尝试分析一个这个问题，**逻辑链上最关键点才是一个知识的精华**
> 
> 如果说你通过观察题目，快速反映出来这个问题可以用动态规划求解，这种能力是一种**熟练能力**，类似于弹钢琴的熟能生巧，背书的死记硬背。与之相对的，就是**分析能力**。很有趣的是，这两种能力的分野十分明显，即**高效和求知**。如果你需要**快速通过面试**，拿到工作或**通过考试**，那大量做题才是最短路径，可学习的目的不止是为了获得生存手段，还有一种**更高级的快乐来自于钻研本身**

回到问题，总结一下，通过上面的解答我们有了什么一些什么**直观的结论**

① `1`个和`2`个鸡蛋的问题已经解决

② 理解了**最大值的最小值**在本题中的含义

③ 答案的值只和**楼层高度**有关，和最低楼层与最高楼层无关

以这三个结论为基石，想一想这道更加一般化的问题如何解决

## 符号化描述

首先，最明显的思考来自于一个设问：❓我们能不能尝试把**鸡蛋的数量减少**？即不断的往`2`个鸡蛋的问题上靠拢？有一个很简单的办法，就是**扔**，扔碎一个，鸡蛋数量就减少一个

按照这个思路，进行一个**抽象推演**，假设在某一个时刻，我们拥有 $m$ 个鸡蛋，层高为 $h$ （h for height），此时，此刻在 $k \in [1, h]$ 层楼扔下一个鸡蛋

### 〔Case - 情况 1〕 碎了

假设我们已经知道 $1$ 到 $k-1$ 层楼最优的解的值，那怎么用一个函数来表示这个值呢？首先看我们需要的自变量有哪些

- 1）此时**剩下的鸡蛋数**，这个非常明显，符号化记为 $m$ 个鸡蛋
- 2）根据`2个鸡蛋`难题时的结论可知，第二个自变量是此时**未知情况楼层的层高**（未知情况只楼层范围内还从来没有用鸡蛋尝试过，无法缩小范围），符号化记为 $h$ （h for height）

⭐️ 用一个表达式 $r = f(h, m)$ 表示**楼高**为 $h$ 时，还**剩下 $m$ 个鸡蛋**时的**最少尝试步数**

因为在 $k$ 层碎了，所以不用考虑`[k+1, N] `层的情况（肯定都碎），并且因为此刻这一个鸡蛋`碎了`，剩下 $m-1$ 个鸡蛋，用公式 $f(k-1, m-1)$ 来表示已经知道的 $1$ 到 $k-1$ 层楼**最少尝试步数**的值，总最小尝试次数为 $f(k-1, m-1)+1$

### 〔Case - 情况 2〕没碎

在 $k$ 层没碎，直接不用考虑`[1, k]`情况了（肯定都不碎），同理，计算出**此时楼高** $h_{now} = h - (k+1) + 1 = h - k$，且因为此刻这个鸡蛋`没碎`，剩下 $m$ 个鸡蛋，即 $f(h-k, m)$ ，总最小尝试次数为 $f(h-k, m)+1$

## 构造逻辑链

此时，我们已经有了三个表达式

① 楼高为 $h$ ，剩下 $m$ 个鸡蛋时的**最少尝试步数**：$f(h, m)$ 

② 在第 $k$ 层扔下`1`个鸡蛋`碎了`后的**最少尝试步数**：$f(k-1, m-1)$

③ 在第 $k$ 层扔下`1`个鸡蛋`没碎`后的**最少尝试步数**：$f(h-k, m)$ 

观察三个表达式，发现可以抽象化出一个决策（在第 $k$ 层楼扔鸡蛋），让答案变成另一种形式，并且**因果关系只和**这3个表达式有关！

那么，假设②③的表达式是**已知的**，是否能用这二者**推出**①呢？如果上述逻辑链成立，就可以用`归纳思维`（数学归纳法）算出任意 $f(h, m)$ 。因为①只能从②③推出，根据题意，要求**最少的尝试步骤**，所以需要选择②③中值更大的那个

因为 $k$ 是一个自变量，在这个条件下，可以取到 $[1, h]$ 中的任意值，⭐️那么思考，假设②③已知，只要穷举出所有 $k$ 的可能值，并且找出**最大尝试步数中的最小值**即可

因为对于①来说，需要一步决策（扔一次鸡蛋），所以数值上，穷举过程的每一步都要**加1**

接下来就可以把这个逻辑链的用抽象化的公式表达出来
$$
f(h, m) = \min_{1 \leqslant k \leqslant h} \{\max [f(k-1, m-1), f(h-k,m)]+1\} \tag{4}
$$

有了具体的公式，在工程思维上，一定要保持严谨，再来看看**边界条件**和**自变量定义域**

### 自变量的定义域

依据题意楼高 $h \geqslant 1$ 且为整数，剩余鸡蛋数 $m \geqslant 1$ 且为整数 

### 边界条件

$f(h, 1) = h$ ，当剩余鸡蛋数为`1`的时候，答案为现在的楼高

$f(0, m) = 0$ ，当楼高为`0`时，无法尝试，答案**记为**`0` ，或者 $f(1,m) = 1$，表示楼高为`1`时，最小尝试次数为`1` 

## 动态规划

现在反过头来再看，计算机学科中，有一部分专门研究这类问题，即**动态规划**

上面的`符号化描述`被称为`定义状态`，`构造逻辑链`被称为`构造状态转移方程`，而背后的工程思维是`拆分思维`、`抽象思维`和`归纳思维`。再究竟一些，动态规划是一类特殊的`图算法`。

- 〔拆分思维〕拆分问题的能力。大问题化小问题，无后效性，当前状态与未来状态无关。
- 〔抽象思维〕使用状态来描述问题的能力，或说用抽象符号或状态机来描述问题的能力
- 〔归纳思维〕数学归纳法，逻辑推导能力。由 $\leqslant i$ 的所有状态推倒出 $i+1$ 时刻状态的能力

之所以要研究这类问题和**计算机本身是一个巨大的状态机**有关。动态规划提供了一套**工具**和**思维框架**去优化问题，找到最优），这个可能才是最厉害的，后面优化部分的详解你就能直观的体会到这一点。

# 实现优化和分析

这部分，通过写出一步一步优化的思路，和对应的代码实现（使用`python`），希望能直观的说明一个问题，`❓ 到底高级程序员和一般的码农程序员区分在哪里？`

每个人都有自己擅长的领域，管理大师**吉姆·柯林斯**的第一本畅销书《基业长青》，书内研究了18家企业成功的秘密。后来，他又出了一本书《从平庸到伟大》，对这个变化的界定非常严格，`平庸`意味着这家公司的业绩低于市场的平均水准，`变得伟大`意味着业绩改变，并且至少持续15年，业绩保持在平均水准的3倍以上。他研究了1435家公司，只找到了11家。通过研究，他发现了这些企业的6个秘诀，其中有一个就是著名的三环理论，如果把企业的三环理论推广到个人，就是问自己下面**三个问题**：

- 我的擅长是什么？
- 我的热爱是什么？
- 我的机会是什么？

而选择这三者的**交集**作为一辈子努力的方向大概率是没什么问题的。作为程序员，可能只是你开始职业生涯的第一步，后面如何发展，**需要对自己的追求和个人能力做一个更深入的挖掘**，才能有个定论

下面即将提及的优化过程完美的**说明了**作为一个`伟大`的程序员需要什么样的基础能力（至少在算法优化这个小领域），这需要**长时间的训练和极强的天赋**。如果你觉得做出这些解答非常吃力，相对应的，你又想**这辈子有所作为**，**追逐伟大**。那么应该尝试去找一个跨界学科开拓自己的人生版图。毕竟，**计算机思维，数据分析和机器学习未来会成为像数学一样的基础能力**，无论在哪一行都会对解决问题有极大的帮助

## 基础版

根据思路直接写出的最直观的代码，如果对递归理解的深，比较易懂直观。用我能想到最直白的语言来描述就是：**假设子状态的结果已知，现在需要做些什么操作，就能得到此状态的答案，并且把这个答案返回给函数即可**（借鉴知乎回答的答案，加上了lru_cache）

```Python
import functools
# python3的functools的一个自带函数, 可以对函数返回结果进行LRU cache, 下次以相同参数调用就不重复计算了
# maxsize=None 不限制大小, 其实就变成是全部都cache下来, 不考虑LRU了
@functools.lru_cache(maxsize=None) # 装饰器 
def f(h, m):
    if h == 0:
        return 0

    if m == 1:
        return h

    result = min ( [ max ( [ f( i - 1, m - 1 ), f( h - i, m ) ] ) for i in range( 1, h + 1 ) ] ) + 1
    return result
```

〔优化〕Recursive（递归）的写法虽然清晰明了漂亮，但在工程上有调用函数的开销，系统栈深度限制等弊端，所以需要写成**循环版本**，否则在工程上是一定会返工，过不了Code review

## 循环版本

```Python
def solve(h, m):
    if h < 1 and m < 1:
        return 0

    f = [ [ i for i in range(h+1) ] for j in range(m+1) ]

    for m_i in range( 2, m + 1 ):
        for h_j in range( 1, h + 1 ):
            for k in range( 1, h_j ):
                f[m_i][h_j]= min ( f[m_i][h_j], 1 + max( f[m_i -1][k - 1], f[m_i][h_j - k]) )
    
    return f[m][h]
```

〔优化〕分析一下时间复杂度和空间复杂度，时间复杂度为 $O(mh^2)$ ，空间复杂度为 $O(hn)$ ，很明显，空间上可以优化到 $O(h)$，原因是状态转移方程只和 $m$ 与 $m-1$ 有关，使用两个数组滚动即可

## 空间优化版本

```Python
def solve_space(h, m):
    if h < 1 and m < 1:
        return 0
    
    f_pre = [i for i in range(h + 1)]
    f_cur = [i for i in range(h + 1)]

    for m_i in range( 2, m + 1 ):
        for h_j in range( 1, h + 1 ):
            for k in range ( 1, h_j ):
                f_cur[h_j] = min ( f_cur[h_j], 1 + max( f_pre[k - 1] , f_cur[h_j - k]) )
        f_pre = f_cur[:]
    
    return f_cur[h]
```

基本到这，对于美国`FAANG`的入门级SDE，到这一步，就十分优秀了。后面的所有的内容，属于`高手`的领域（博主完全不是高手，只是好奇，所以阅读了其他人的牛逼的解题报告，在此记录）

对于这一套状态描述和状态转移方程，优化方向在时间复杂度上。先思考，❓是否有一些数学定理可以提供一下答案取值的下界呢？（因为通过上面的分析，和树有关）

〔优化〕这里需要使用数据结构中[折半查找判定树](https://blog.csdn.net/qq_28409193/article/details/50484638)理论。假设我们对鸡蛋的数量不做限制，那么这棵树

<div align="center"><img src="【直观算法】Egg Puzzle 鸡蛋难题/FullTree.png" alt="" width="700"></div>

就会变为一个**满二叉树**，而叶子节点数量有 $h+1$ 个（因为最大尝试步数能取到的总数就是 $h+1$ 种，需包含0次）树的高度至少为 $\lceil \log_2(h+1)\rceil$。假设鸡蛋 $m$ 的数量大于 $\lceil \log_2(h+1)\rceil $ ，那么上面的树**变成满树**，无论怎么尝试，答案（树高）都有一个下界（不可能大于这个值）

如果还不太明白，即在 $m \geqslant \lceil \log_2(h+1)\rceil $ 时，这道题完全变成了**二分查找**（鸡蛋太多，随便扔，就当楼层是排序好的即可）最终答案直接取 $\lceil \log_2(h+1)\rceil$ 即可

如果还是不太明白，上终极杀招，举例子，假设`16`层楼，但有`4`个鸡蛋，根本不用设计，二分查找即可，效率肯定最高。比如`16`层楼，只要鸡蛋数大于`4`，最大尝试次数就是`4`，可以直接算出答案

## 下界优化

```python
def solve_boundary(h, m):
    if h < 1 and m < 1:
        return 0
    
    f_pre = [i for i in range(h + 1)]
    f_cur = [i for i in range(h + 1)]

    for m_i in range( 2, m + 1 ):
        for h_j in range( 1, h + 1 ):
            t = math.ceil( math.log2( h_j + 1 ) )
            if m_i >= t:
                f_cur[h_j] = t
            else:
                for k in range ( 1, h_j ):
                    f_cur[h_j] = min ( f_cur[h_j], 1 + max( f_pre[k - 1] , f_cur[h_j - k]) )
        f_pre = f_cur[:]
    
    return f_cur[h]
```

这时候时间复杂度优化为 $O(mhlog_2(h))$。此时，如果列出所有状态转移的过程（行为鸡蛋数 $m$，从2开始；列为楼高 $h$ ，从1开始），如下图（红色框表示 $k$ 的移动，蓝色双向箭头表示 $\max$ 操作，然后还需要加1后和之前的 $f(m,h)$ 进行 $\min$ 操作。下图展示的是 $m_i=2,h_j=11,k=5$ 时的情况）（这幅图也能帮助理解下界优化，注意 $m_i=5$ 和 $m_i=4$ 在 $h < 20$ 的情况即可）

 <div align="center"><img src="【直观算法】Egg Puzzle 鸡蛋难题/f.png" alt="" width="1000"></div>

有个很重要规律，即单调性，写成公式为 $f(m, h) \geqslant f(m, h-1)$ 当 $h \geqslant 1$ ，如果满足**单调性**，那么又可以在搜索时使用**二分查找**。先姑且不考虑如何证明单调性，工程上，在资源允许的情况下，先尝试一下，看看能不能得到相似的结果，然后用一个正确算法和这个尝试算法进行验证，直到很大的时候如果都没问题，姑且可以觉得这个猜测是对的（不严谨，但是效率较高）

通过这一层优化，**体现出了理论和工程的分野**，即你猜想出了一个优化方法，当然可以先直接尝试，**不管这个猜测的条件是不是正确**，总是心里不踏实的，可能出现**特殊情况**就让整个算法崩溃。此时，理论出山，用严谨的数学逻辑去证明这些结论，让算法具有完备性（本体的这个猜想是对的，证明过程参见参考文献）

> 另外，**观察和总结答案的分布规律**也是非常重要的思考手段，你会发现，这简单的一句话说开去，是一个新的学科，名字叫做**统计学**

## 单调性优化

```python
def solve_binary_search(h, m):
    if h < 1 and m < 1:
        return 0

    t = math.floor( math.log2( h ) ) + 1
    
    if m >= t:
        return t
    else:
        f_cur = [i for i in range(h + 1)]
        f_pre = [i for i in range(h + 1)]

        for m_i in range(2, m + 1):
            f_cur[0] = 0
            for h_j in range(1, h + 1):
                f_cur[h_j] = 1000000
                start = 1
                stop = h_j
                # 二分查找
                while start <= stop:
                    mid = (start + stop) // 2
                    if f_pre[mid - 1] > f_cur[h_j - mid]:
                        if f_pre[mid - 1] + 1 < f_cur[h_j]:
                            f_cur[h_j] = f_pre[mid - 1] + 1
                        stop = mid - 1
                    elif f_pre[mid - 1] < f_cur[ h_j - mid]:
                        if f_cur[h_j - mid] + 1 < f_cur[h_j]:
                            f_cur[h_j] = f_cur[h_j - mid] + 1
                        start = mid + 1
                    else:
                        f_cur[h_j] = f_cur[h_j - mid] + 1
                        break
            f_pre = f_cur[:]
        return f_cur[h]
```

结果的简单特性部分挖掘完了，继续观察上面的**状态转移图**，发现**很多项其实是相等的**，那么可不可以找到，在某种条件满足时，状态可以直接推出，而不用进行 $k$ 的搜索？这个时候就需要从状态转移方程本身入手是挖掘其中的数学特性

{% raw %}
$$
\begin{array}&
f(h, m) = \min\limits_{1 \leqslant k \leqslant h} \{\max [f(k-1, m-1), f(h-k,m)]+1\} \\
f(h, m) \leqslant \max [f(k-1, m-1), f(h-k,m)]+1 \quad(1 \leqslant k \leqslant h) \\
令\; k = 1 \implies f(h, m) \leqslant f(h - 1, m) + 1
\end{array}
$$
{% endraw %}

又因为 $f$ 具有单调性，可得 $f(h - 1, m) \leqslant f(h, m) \leqslant f(h - 1, m) +1$ 其中 $h\geqslant 1$  

上面的式子非常有意思，使用标准的逻辑推理来看

- 若某个决策 $k$ 可使得 $f(h - 1, m) = f(h, m)$ ，则一定 $f(h, m) = f(h-1, m)$

- 若所有决策 $k$ 都**不能**使 $f(h - 1, m) = f(h, m)$ ，则一定 $f(h, m) = f(h - 1, m) + 1$ 

那么，是否可以构造这样一个决策，使得状态转移直接计算呢？**具体过程略过**，有兴趣的读者详见参考文献

假设这个决策的楼高 $h = p$ ，推倒出当 $f(m, p)<f（m-1， h-p-1)$ 时，无论任何决策都不能使 $f(m, h) = f(m, h-1)$，所以，此时 $f(m, h) = f(m, h-1) + 1$ 

也就是说，只需根据 $f(m, p)$ 和 $f(m-1,h-p-1)$ 的大小关系就可以直接确定 $f(m, h)$ 

## 状态转移方程优化

```python
def solve_transfer_function(h, m):
    if h < 1 and m < 1:
        return 0

    t = math.floor( math.log2( h ) ) + 1
    
    if m >= t:
        return t
    else:
        f_cur = [i for i in range(h + 1)]
        f_pre = [i for i in range(h + 1)]

        for m_i in range(2, m + 1):
            p = f_cur[0] = 0
            f_cur[1] = 1
            for j in range(2, h + 1):
                if f_cur[p] >= f_pre[j - p - 1]:
                    f_cur[j] = f_cur[j - 1]
                else:
                    f_cur[j] = f_cur[j - 1] + 1
                    p = j - 1
            f_pre = f_cur[:]
        
        return f_cur[h]
```

此时，状态转移过程时间复杂度变成 $O(1)$，整体时间复杂度随之变成 $O(m\log_2{h})$ 

在这种依照题意直接定义状态并找到状态转移方程的方法已经优化到极致了。那么，❓ 如果从不同的角度定义问题呢？

## 不同角度看问题

### 状态定义

改变对问题的状态描述方法，用 $h(i,j)$ [h for height]表示用 $j$ 个鸡蛋尝试 $i$ 次在最坏情况下能找到的最小尝试次数的**楼高**

### 边界条件

当尝试次数 $i=1$ 时，$h(1,j)=1\quad(j \geqslant 1)$ 

当使用 $j = 1$ 个鸡蛋时，尝试 $i$ 次可以在 $i$ 层楼的高度内找到最小尝试次数，即 $h(i,1)=i$

### 状态转移方程

在某层扔下一个鸡蛋

- 〔碎了〕那么在后面的 $i-1$ 次里，需用 $j-1$ 个鸡蛋在下面的楼层中确定**楼高**。为了使 $h(i,j)$ 达到最大，希望下面的楼层数（楼高）最大，根据状态定义，可以写为 $h(i-1, j-1)$ 
- 〔没碎〕那么在后面的 $i-1$ 次里，需用 $j$ 个鸡蛋在上面的楼层中确定**楼高**。同理，需要楼层数达到最大，记为 $h(i-1,j)$ 

综上，状态转移方程写为 $h(i,j) = h(i-1, j-1)+h(i-1,j) + 1$

而最终结果可以写为，找到一个 $x$ ，使得 $x$ 满足 $h(x-1, M) < H$ 且 $h(x, M) \geqslant H$ （$M$ 为鸡蛋总数，$H$ 为楼层总高度），其实也就是用公式描述的临界层的具体含义

### 代码实现

```python
def g(h, m):
    if h < 1 and m < 1:
        return 0

    t = math.floor( math.log2( h ) ) + 1
    
    if m >= t:
        return t
    else:
        g_cur = g_pre = [ 1 for i in range(m + 1) ]
        g_cur[0] = g_pre[0] = 0

        if g_cur[m] >= h:
            return 1
        elif h == 1:
            return h
        else:
            for i in range(2, h + 1):
                for j in range( m, 1, -1):
                    g_cur[j] = g_pre[j - 1] + g_pre[j] + 1
                    if g_pre[j] < h and g_cur[j] >= h:
                        return i
                g_cur[1] = i
                if m == 1 and g_cur[1] >= h:
                    return i
                print( g_cur, end="\n")
                g_pre = g_cur[:]
```

### 继续优化

这又是一个全新的状态定义和状态转移方程，同理，可尝试**输出整个转移矩阵的具体值**，先观察一下总没有错，如下图所示 

 <div align="center"><img src="【直观算法】Egg Puzzle 鸡蛋难题/g.png" alt="" width="400"></div>

从形式上来说，不需要滚动数组，在转移过程中，使用一个 $g$ 函数即可。在最后输出的时候，只需要判断`g[m]`的情况输出 $i$  

```python
def g_optimization(h, m):
    if h < 1 and m < 1:
        return 0

    t = math.floor( math.log2( h ) ) + 1
    
    if m >= t:
        return t
    else:
        g = [ 1 for i in range(m + 1) ]
        g[0] = 0

        if g[m] >= h:
            return 1
        elif h == 1:
            return h
        else:
            for i in range(2, h + 1):
                for j in range( m, 1, -1):
                    g[j] = g[j - 1] + g[j] + 1
                    if j == m and g[j] >= h:
                        return i
                g[1] = i
                if m == 1 and g[1] >= h:
                    return i

```

要分析时间复杂度，这个问题非常难，通过证明可以有一个结论（具体证明详见参考文献）$xM \leqslant H$ ，再通过一系列骚操作，可以证明时间复杂度为 $O(\sqrt{h})$，空间复杂度 $O(m)$ 

至此，Leetcode上这道题目的执行时间打败了85.7%的答案，做这道题的人不多，前面只有一个答案，思路类似，代码写的更漂亮

# 工程思维总结和感悟

## 工程思维 

⭐️ 这一部分是【直观算法】系列的最终目的，求同，去寻找每一道算法题的工程思维，提升自己真正解决工程问题的能力，博主对自己的定位是【机器学习+区块链产品经理】，但同时对技术也有好奇心，喜欢钻研，才开启了【直观算法】系列

### 抽象思维

把语言描述转化为符号描述的能力，符号是信息和逻辑的纽带

### 等价思维

**沟通的效率和信息的冗余度成正比**，所以一个人能否把同一个概念，**从不同的角度，用不同的案例类比，抑或各类精彩直观的比喻**表达出来，这个能力很重要，它可以让人们更加**准确快速的**理解你想表达的意思

⭐️ **学习的真正本质**：**是在一个领域内不断的去建立这种沟通共识的框架**。举个例子，学过线性代数的人，只要**提到矩阵，就能想到变换**。这就是都学过线性代数的人交流密码，如矩阵的逆 = 一个具体的反向变换。没学过这门课的人是无法和**学过的人**进行沟通的。这也从很大程度加强了人们沟通的效率，所以，**学习带来的终极成效**其实是降低了**人类社会的沟通时间，提高了效率**

再举个例子：机器学习中，提到**正则化**，必须建立一套与之相关的知识架构，包括，**过拟合，最优化函数曲面空间理解，范数**等，成**树状结构**继续推而广之，这每一个名词，背后也对应了一个**更加直观，更加易懂的描述方式**。但是我们需要知道，如果我为了表达正则化，为了让你明白我的意思，我需要用一大堆描述性语言，那我们两人的**沟通效率就十分低下了**

这也就是知识体系，一门学科，一门专业的最终含义，学习是为了**构建这门学科的通识沟通框架**，降低同行之间的沟通成本。当然，这有一个**必要前提**，把**学习的目的**理解降**低沟通成本**必须是你做的工作**是规模化的**，涉及**协作**。如果你是爱因斯坦，是开拓学科的那类**0级工程师**（来自于吴军老师谷歌方法论）。独自想象钻研，那么，学习的本质可能在于给你更多的角度（认知能力），更多的工具（锤子锯子）去更好的**探索这个世界的本质和规则**，在这样的条件下，关于**学习本质的描述**就需要调整了

### 反推思维

从结论出发反推逻辑链

### 归纳思维

数学归纳法，使用已有的条件信息，归纳推出待求的内容

### 粗条细调思维

对于这道题，首先考察的是程序员的粗条细调思维。工程中经常会有对**测量精度**的要求，那么是如何做的？比如常见的**千分尺**，首先是一个横向的卡尺来接近目标值，然后用一个滚轮形的第二级继续细调。同样，显微镜也有对应的调整方法。都可以总结为`粗条细调思维`

首先大步接近最优解，再调整迭代速度，更加细微的接近最优解。机器学习中的，Adam优化器也是用类似的思维来设计的

### 拆分思维

问题是否能拆分几个黑盒，只给输入输出，里面的逻辑链做到精简，或者**有已经可用的轮子**和**算法**直接应用的能力。

> 能看到这的读者我衷心感谢您的求知欲和耐心（我写的比较啰嗦，为了权衡不同背景的读者），下面的一部分个人认为**才是最重要的**

## 工程应用

到了这一步，基本压榨了本题所有的潜力。但是，下一个值得思考的问题就是，这道题目对应的算法在**实际工程和解决问题的具体情况**中有没有什么应用呢？答案是肯定的

如果要找学科分类，鸡蛋难题属于**运筹学问题**，典型应用是破坏性试验，如测试汽车、飞机、火箭等的若干极限性能。举个例子，汽车保全乘客安全的最高碰撞末速，那么为了保证能找这个值，一定会用类似的思路来解决问题。

你可能也已经发现，具体问题一定还是具体分析，但这道题目对应的工程思维更像是工具箱里面的一种**更强大的工具。**记得罗辑思维中提到，为什么物理学老一辈的物理学家现在拿奖的人越来越少，其中一个重要的原因即使他们的物理学工具没有新生一辈的能力强大的，不同于数学这类逻辑学科，物理学是可验证学科，实验和测量工具，理论工具等都是必不可少的。

博主笃定，算法**80%是要为解决问题服务的**，勾起人们学习的最佳动力就是**举实际生活中遇到的难题是如何用这个算法解决的**。从这个侧面，有关字符串的算法就非常能勾起学习的兴趣，正是因为涉及到字符串处理的情景太多。

总得看下来，完美的诠释了直观 ➜ 抽象的思维链条。所有高效的，精简的算法，就是要**找到事物或者逻辑发生的本质规律**，如果不谈完备性的证明，用**图表和直观的性质来描述**，这道题目的优化思路并不难（相对的，完备性时间复杂度的证明才是难点）

关于剩下的20%，此时又想起了[黎曼猜想](https://charlesliuyx.github.io/2018/09/20/%E3%80%90%E7%9B%B4%E8%A7%82%E8%AF%A6%E8%A7%A3%E3%80%91%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E4%BA%86%E8%A7%A3%E4%BB%80%E4%B9%88%E6%98%AF%E9%BB%8E%E6%9B%BC%E7%8C%9C%E6%83%B3/)，**所有**非平凡零点的有关性质。`趋向于无穷`、`所有`、`任意`这些定义方式是人类为了**寻找边界**而设计的工具。趋向于无穷大，趋向于无穷小都还有很多问题没有解决。罗振宇说，创业者是在开垦商业的边疆，那么理论科学家就是拿着这些强大的工具开拓**逻辑和思维的边疆**，在一片荒芜上安营扎寨，仰望星空。这可能就是人类群体中**最有魅力的事业**吧？



【参考文献】

非常感谢计算机信息学奥赛国家队朱前辈的论文，对这道题目做了完美的剖析，也勾起了我的好奇心，一探究竟，才有了这篇**万字长文**

[吴育昕的回答 - 知乎](https://www.zhihu.com/question/19690210/answer/18079633)

[参考文献：朱晨光：《优化，再优化！——从《鹰蛋》一题浅析对动态规划算法的优化》](https://github.com/ericliu859/AcmPaper/tree/master/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E4%BC%98%E5%8C%96/2004%20-%20%E6%9C%B1%E6%99%A8%E5%85%89%EF%BC%9A%E3%80%8A%E4%BC%98%E5%8C%96%EF%BC%8C%E5%86%8D%E4%BC%98%E5%8C%96%EF%BC%81%E2%80%94%E2%80%94%E4%BB%8E%E3%80%8A%E9%B9%B0%E8%9B%8B%E3%80%8B%E4%B8%80%E9%A2%98%E6%B5%85%E6%9E%90%E5%AF%B9%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96%E3%80%8B)

