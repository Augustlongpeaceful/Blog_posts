---
title: 【直观算法】树的基本操作
date: 2018-10-22 15:53:27
tags: 
- Tree
- Optimization
categories:
- Algorithm
---

【阅读时间】
【阅读内容】结合应用场景，总结有关树的遍历（前序中序后序），二叉搜索树的算法解法和面试题，附带提及一些自平衡二分查找树（红黑树AVL树）的概念和用法

<!-- more -->

# 遍历

遍历的含义就是把树的所有节点（Node）按照**某种顺序**访问一遍。包括**前序**，**中序**，**后续**，**广度优先**（队列），**深度优先**（栈）5中遍历方法

| 遍历方法 |           顺序           |                            示意图                            |                             应用                             |
| :------: | :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   前序   |     **根 ➜ 左 ➜ 右**     | <div align="center"><img src="【直观算法】树的基本操作/Pre-Order.png" alt="" width="150"></div> |         想在节点上直接执行操作（或输出结果）使用先序         |
|   中序   |     **左 ➜ 根 ➜ 右**     | <div align="center"><img src="【直观算法】树的基本操作/In-Order.png" alt="" width="150"> | 在**二分搜索树**中，中序遍历的顺序符合从小到大（或从大到小）顺序的，要输出排序好的结果使用中序 |
|   后序   |     **右 ➜ 根 ➜ 左**     | <div align="center"><img src="【直观算法】树的基本操作/Post-Order.png" alt="" width="150"> | 后续遍历的特点是在执行操作时，肯定**已经遍历过该节点的左右子节点**，适用于进行破坏性操作，比如删除所有节点，比如判断树中是否存在相同子树 |
| 广度优先 |    **层序，横向访问**    | <div align="center"><img src="【直观算法】树的基本操作/Breadth-First.png" alt="" width="150"> |    当**树的高度非常高**（非常瘦），使用广度优先剑节省空间    |
| 深度优先 | **纵向，探底到叶子节点** | <div align="center"><img src="【直观算法】树的基本操作/Deep-First.png" alt="" width="150"> | 当**每个节点的子节点非常多**（非常胖），使用深度优先遍历节省空间 |

关于应用部分，选择遍历方法的基本的原则：<span style="font-weight:bold;color: red">更快的访问到你想访问的节点</span>。先序会先访问根节点，后序会先访问叶子节点

需要说明的是，递归是一种`拆分思维`的具体问题类别的思维方法，其核心的思维我觉得和动态规划非常类似，都是假设，子节点搞定了我现在应该干什么这个问题。

## 先序遍历

如果想练手，见[Leetcode 44. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)，给一个表示树形状的数据结构，按照要求进行输出遍历结果

# 二叉搜索树