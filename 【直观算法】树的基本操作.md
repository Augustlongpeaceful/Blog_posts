---
title: 【直观算法】树的遍历最全总结
date: 2018-10-22 15:53:27
tags: 
- Tree
- Optimization
categories:
- Algorithm
---

【阅读时间】
【阅读内容】结合应用场景，总结有关树的遍历的所有算法和对应Leetcode题目编号。基于`Python`代码，给出完整逻辑链。希望给读者一个线头，让你永远忘不了这几个遍历算法

<!-- more -->

遍历的含义就是把树的所有节点（Node）按照**某种顺序**访问一遍。包括**前序**，**中序**，**后续**，**广度优先**（队列），**深度优先**（栈）5中遍历方法

| 遍历方法 |           顺序           |                            示意图                            |                             应用                             |
| :------: | :----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   前序   |     **根 ➜ 左 ➜ 右**     | <div align="center"><img src="【直观算法】树的基本操作/Pre-Order.png" alt="" width="150"></div> |         想在节点上直接执行操作（或输出结果）使用先序         |
|   中序   |     **左 ➜ 根 ➜ 右**     | <div align="center"><img src="【直观算法】树的基本操作/In-Order.png" alt="" width="150"> | 在**二分搜索树**中，中序遍历的顺序符合从小到大（或从大到小）顺序的，要输出排序好的结果使用中序 |
|   后序   |     **左 ➜ 右 ➜ 根**     | <div align="center"><img src="【直观算法】树的基本操作/Post-Order.png" alt="" width="150"> | 后续遍历的特点是在执行操作时，肯定**已经遍历过该节点的左右子节点**，适用于进行破坏性操作，比如删除所有节点，比如判断树中是否存在相同子树 |
| 广度优先 |    **层序，横向访问**    | <div align="center"><img src="【直观算法】树的基本操作/Breadth-First.png" alt="" width="150"> |    当**树的高度非常高**（非常瘦），使用广度优先剑节省空间    |
| 深度优先 | **纵向，探底到叶子节点** | <div align="center"><img src="【直观算法】树的基本操作/Deep-First.png" alt="" width="150"> | 当**每个节点的子节点非常多**（非常胖），使用深度优先遍历节省空间 |

关于应用部分，选择遍历方法的基本的原则：<span style="font-weight:bold;color: red">更快的访问到你想访问的节点</span>。先序会先访问根节点，后序会先访问叶子节点

需要说明的是，递归是一种`拆分思维`的具体问题类别的思维方法，其核心的思维我觉得和动态规划非常类似，都是**假设子节点搞定了我现在应该干什么**这个问题

先确定`Python`语言下的`TreeNode`定义

```python
class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
```

需要输出遍历结果时直接输出保存`val`的数组即可

> 关于递归算法的解释，博主打算写一份[【直观算法】汉诺塔问题最全解答]()，过后可能会更新，是一篇小品文，可能会比较短，这篇文章只是希望让所有阅读的人能一次就直观的搞明白汉诺塔的算法是怎么做的，永远记住它，也搞懂递归算法

三种遍历方法，都有一个特点，无论是先序`根 ➜ 左 ➜ 右`，中序`左 ➜ 根 ➜ 右`，后序`左 ➜ 右 ➜ 根`，所谓的**访问顺序**，根是最重要，根才代表了**访问**这个动作（在我们的代码中，就是把节点中的**值**加入到输出数组中），⭐️而`根`在的位置决定了**是否可以访问的条件**

比如对于**中序**来说，`根`在`左`的后面，意味着，只要当前操作的节点有`左`节点，就不能输出`根`里面的值

对于**后序**来说，有了这个直观理解，对理解三者的迭代算法有帮助

## 先序遍历

在线刷题：[Leetcode 44. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/)

### 递归算法

所谓递归（Recursive），即把函数本身**看成一个已经有解的子问题**

定义函数`preorderTraversal(self, node)`返回以`node`为答案的先序遍历结果的数组，假设它的两个孩子`node.left`和`node.right`已经搞定了，即可以返回答案的输出数组。那么思考最终的输出数组是什么样的，很明显要满足`根 ➜ 左 ➜ 右`的规则，应该返回`[node.val] + preorderTraversal(self, node.left) + preorderTraversal(self, node.right)`（函数返回的就是一个数组，只需要把它们拼接起来即可）

之后再完善防御性编程的基本步骤（保证函数输入有效），按照这个思路就可以写出先序遍历的递归代码。`Python`代码的特点是可读性比较强，这样一行代码简洁明了，能简洁的表达上面的**逻辑链推理过程**

```python
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        return [] if root is None else [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)
```

当然，如果不使用`Python`，在语法上无法写的这么简短。常见的**标准**写法是使用`helper()`函数，具体实现见下

```python
def preorderTraversal1(self, root):
    result = []
    self.helper(root, result)
    return result
    
def helper(self, root, result):
    if root:
        result.append(root.val)
        self.helper(root.left, result)
        self.helper(root.right, result)
```

### 迭代算法

同理，递归算法使用系统栈，不好控制，性能问题比较严重，需要进一步了解不用递归如何实现。先序遍历使用**一个栈**

先处理根节点，根据访问顺序`根 ➜ 左 ➜ 右`，先入栈的后访问，为了保持访问顺序，**⭐️先把右孩子入栈，再入栈左孩子**（此处需要注意）

```python
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        result, stack = [], [root]
    
        while stack:
            curNode = stack.pop()
            result.append(curNode.val)
            if curNode.right:
                stack.append(curNode.right)
            if curNode.left:
                stack.append(curNode.left)
                
        return result
```

## 中序遍历

在线刷题：[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)

### 递归算法

同理于前序遍历，一模一样的处理方法，考虑访问顺序为`左 ➜ 根 ➜ 右`即可，快速模仿并写出代码

```python
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        return [] if root is None else self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)
```

同理在这里也附上使用`helper()`函数的标准写法，代码上来说，只**变了名称**和**访问顺序**

```python
def inorderTraversal1(self, root):
    result = []
    self.helper(root, result)
    return result
    
def helper(self, root, result):
    if root:
        self.helper(root.left, result)
        result.append(root.val)
        self.helper(root.right, result)
```

### 迭代算法

核心思路依旧是利用栈维护节点的访问顺序：`左 ➜ 根 ➜ 右`。使用一个`pNode`来指向当前**访问节点**，`p`是代表指针`point`，另外有一个变量`curNode`表示当前正在**操作节点**（把出栈节点值加入输出数组中），算法步骤如下（可以对照代码注释）

① 访问当前节点，如果当前节点有左孩子，则把它的左孩子都入栈，移动当前节点到左孩子，重复第一步直到**当前节点**没有左孩子

② 当**当前节点**没有左孩子时，栈顶节点出栈，加入结果数组

③ **当前节点**指向**栈顶节点**的右节点

```python
class Solution:
    def inorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        result, stack = [], []
        
        pNode = root # 当前访问节点指针
        while pNode or stack:
            
            while pNode: # 把所有当前访问节点的左孩子都入栈
                stack.append(pNode)
                pNode = pNode.left
            
            curNode = stack.pop() # 操作栈顶节点，如果是第一次运行到这步，那么这是整棵树的最左节点
            result.append(curNode.val) # 因为已经保证没有左节点，可以访问根节点
            if curNode.right:
            	pNode = curNode.right # 将指针指向当前节点的右节点
        
        return result
```

如果想要精简代码，从逻辑上来看，`pNode`可以使用`root`代替，这样写只是为了让代码更可读，和逻辑链相切合，方便理解

## 后续遍历

在线刷题：[145. Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)

### 递归算法

同理[先序遍历](#先序遍历)，代码如下

```python
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        
        return [] if root is None else self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]
```

节省版面，使用`helper()`函数的写法只需要改变**函数名**和**访问顺序**

### 迭代算法 1

访问顺序为`左 ➜ 右 ➜ 根`，在对**访问节点**进行**操作**的条件是，它的**左子树和右子树都已经被访问了**，这样算法的框架就出来了，只需要对每个节点进行标记，表示这个节点有没有被访问，一个节点能否进行**操作**的条件就是这个节点的左右节点都被访问过了。

因为栈的规则是`先入后出`，为了维护访问顺序满足条件，入栈顺序应该是`根 ➜ 右 ➜ 左`。代码如下

```python
class Solution:
    def postorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if root is None:
            return []
        
        result, stack = [], [(root, False)]
        
        while stack:
            curNode, visited = stack.pop()
            if visited: # 只有访问状态为True的节点才能被操作
                result.append(curNode.val)
            else:
                stack.append((curNode, True))
                if curNode.right:
                    stack.append((curNode.right, False))
                if curNode.left:
                    stack.append((curNode.left, False))
                    
        return result
```

### 迭代算法 2

还有一种迭代算法利用后序遍历的本身属性，注意到后序遍历的顺序是`左 ➜ 右 ➜ 根`，那么反序的话，就直接倒序的输出结果，即**反后序**：`根 ➜ 右 ➜ 左`，和先序遍历的`根 ➜ 左 ➜ 右`对比，发现只需要稍微改一下代码就可以得到**反后序**的结果，参考先序遍历，代码如下

```python
class Solution:
    def preorderTraversal(self, root):
        """
        :type root: TreeNode
        :rtype: List[int]
        """
        if not root:
            return []
        
        result, stack = [], [root]
    
        while stack:
            curNode = stack.pop()
            result.append(curNode.val)
            if curNode.left: # 修改顺序
                stack.append(curNode.left)
            if curNode.right: # 修改顺序
                stack.append(curNode.right)
                
        return result[::-1] # 反序操作
```



# 二叉搜索树